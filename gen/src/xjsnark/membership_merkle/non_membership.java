package xjsnark.membership_merkle;

/*Generated by MPS */

import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.FieldElement;
import java.math.BigInteger;
import xjsnark.poseidon.PoseidonHash;
import backend.structure.CircuitGenerator;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;

public class non_membership {

  public static final int HEIGHT = 21;

  // non_membership proof function
  // It uses F_p[8] as its input_domain_name's format and takes MerkleAuthPath structure as its input format
  public static UnsignedInteger check_membership_path(FieldElement[] input_domain_name, FieldElement root, FieldElement left_leaf, FieldElement right_leaf, MerkleAuthPath authPath_left, MerkleAuthPath authPath_right) {

    // compute the hash of input_domain_name in the first layer 
    // The needs an 8-input Poseidon Hash since domain name has a larger size 
    FieldElement leaf = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    leaf.assign(PoseidonHash.poseidon_hash_8(input_domain_name));

    // compute the Merkle Root using left_left and right_left verifiably 
    FieldElement left_root = authPath_left.computeMerkleRoot(left_leaf.copy()).copy();
    FieldElement right_root = authPath_right.computeMerkleRoot(right_leaf.copy()).copy();

    // compare that roots are the same (public input root, roots computed from left and right) 
    // It can prove that both left_leaf and right_leaf exist in Merkle Tree 
    left_root.forceEqual(root);
    right_root.forceEqual(root);

    // Prove that left_leaf and right_leaf are adjacent! 
    // The directionSelector is exactly the same as leaf's index position in first layer 
    UnsignedInteger one = new UnsignedInteger(8, new BigInteger("1"));
    authPath_left.directionSelector.add(one).forceEqual(authPath_right.directionSelector);

    // Prove that left_leaf is indead smaller than right_leaf 
    // We can only compare uint, so we need such convert 
    UnsignedInteger left_leaf_uint = UnsignedInteger.instantiateFrom(256, left_leaf).copy(256);
    UnsignedInteger right_leaf_uint = UnsignedInteger.instantiateFrom(256, right_leaf).copy(256);
    UnsignedInteger leaf_uint = UnsignedInteger.instantiateFrom(256, leaf).copy(256);
    CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_leaf_uint.isLessThan(leaf_uint).getWire());
    CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(leaf_uint.isLessThan(right_leaf_uint).getWire());

    return UnsignedInteger.instantiateFrom(1, 1);
  }


  // wildcard non_membership proof function
  // It takes uint_8[255] as its input_domain_name's format and takes Merkle Path and directionSelector directly as its input format
  public static UnsignedInteger check_wildcard_python_path(UnsignedInteger[] input_domain_name_wildcard, FieldElement root, UnsignedInteger[] left_domain_name, UnsignedInteger[] right_domain_name, UnsignedInteger left_index, UnsignedInteger right_index, FieldElement[] left_path_array, FieldElement[] right_path_array, UnsignedInteger left_dir, UnsignedInteger right_dir) {

    // construct MerkAuthPath structure (compute root for left_path and right_path later) 
    MerkleAuthPath authPath_left = new MerkleAuthPath(left_dir.copy(64), left_path_array);
    MerkleAuthPath authPath_right = new MerkleAuthPath(right_dir.copy(64), right_path_array);

    // convert the left and right domain name toF_p[8] to be accepted by Poseidon Hash 
    FieldElement leaf = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    FieldElement[] left_domain_name_input = convert_8_to_Fp_python(left_domain_name);
    FieldElement[] right_domain_name_input = convert_8_to_Fp_python(right_domain_name);

    // compute the hash of left and right domain name in the first layer 
    // The needs an 8-input Poseidon Hash since domain name has a larger size 
    FieldElement left_leaf = PoseidonHash.poseidon_hash_8(left_domain_name_input).copy();
    FieldElement right_leaf = PoseidonHash.poseidon_hash_8(right_domain_name_input).copy();

    // compute the Merkle Root using left_left and right_left verifiably 
    FieldElement left_root = authPath_left.computeMerkleRoot(left_leaf.copy()).copy();
    FieldElement right_root = authPath_right.computeMerkleRoot(right_leaf.copy()).copy();

    // compare that roots are the same (public input root, roots computed from left and right) 
    // It can prove that both left_leaf and right_leaf exist in Merkle Tree 
    left_root.forceEqual(root);
    right_root.forceEqual(root);

    // Prove that left_leaf and right_leaf are adjacent! 
    // The directionSelector is exactly the same as leaf's index position in first layer 
    UnsignedInteger one = new UnsignedInteger(8, new BigInteger("1"));
    authPath_left.directionSelector.add(one).forceEqual(authPath_right.directionSelector);

    // Prove that left_leaf is indead smaller than right_leaf 
    // This firstly checks left_index and right_index for exact matching and then checks the next is smaller 
    // check out the notes for the algorithm 
    for (int i = 0; i < 255; i++) {
      {
        Bit bit_a0gb0k = UnsignedInteger.instantiateFrom(8, i).isLessThan(left_index).copy();
        boolean c_a0gb0k = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0gb0k);
        if (c_a0gb0k) {
          if (bit_a0gb0k.getConstantValue()) {
            left_domain_name[i].forceEqual(input_domain_name_wildcard[i]);
          } else {
            {
              Bit bit_a0a0a0a2a0a23a01 = UnsignedInteger.instantiateFrom(8, i).isEqualTo(left_index).copy();
              boolean c_a0a0a0a2a0a23a01 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a0a2a0a23a01);
              if (c_a0a0a0a2a0a23a01) {
                if (bit_a0a0a0a2a0a23a01.getConstantValue()) {
                  CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isLessThan(input_domain_name_wildcard[i]).getWire());
                  CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isNotEqualTo(UnsignedInteger.instantiateFrom(8, 0)).getWire());
                } else {

                }
              } else {
                ConditionalScopeTracker.pushMain();
                ConditionalScopeTracker.push(bit_a0a0a0a2a0a23a01);
                CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isLessThan(input_domain_name_wildcard[i]).getWire());
                CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isNotEqualTo(UnsignedInteger.instantiateFrom(8, 0)).getWire());

                ConditionalScopeTracker.pop();

                ConditionalScopeTracker.push(new Bit(true));

                ConditionalScopeTracker.pop();
                ConditionalScopeTracker.popMain();
              }

            }

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0gb0k);
          left_domain_name[i].forceEqual(input_domain_name_wildcard[i]);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          {
            Bit bit_a0a0a23a01_0 = UnsignedInteger.instantiateFrom(8, i).isEqualTo(left_index).copy();
            boolean c_a0a0a23a01_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a23a01_0);
            if (c_a0a0a23a01_0) {
              if (bit_a0a0a23a01_0.getConstantValue()) {
                CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isLessThan(input_domain_name_wildcard[i]).getWire());
                CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isNotEqualTo(UnsignedInteger.instantiateFrom(8, 0)).getWire());
              } else {

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a0a23a01_0);
              CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isLessThan(input_domain_name_wildcard[i]).getWire());
              CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(left_domain_name[i].isNotEqualTo(UnsignedInteger.instantiateFrom(8, 0)).getWire());

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }
          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }

      {
        Bit bit_c0gb0k = UnsignedInteger.instantiateFrom(8, i).isLessThan(right_index).copy();
        boolean c_c0gb0k = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_c0gb0k);
        if (c_c0gb0k) {
          if (bit_c0gb0k.getConstantValue()) {
            right_domain_name[i].forceEqual(input_domain_name_wildcard[i]);
          } else {
            {
              Bit bit_a0a0a0a2a2a23a01 = UnsignedInteger.instantiateFrom(8, i).isEqualTo(right_index).copy();
              boolean c_a0a0a0a2a2a23a01 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a0a2a2a23a01);
              if (c_a0a0a0a2a2a23a01) {
                if (bit_a0a0a0a2a2a23a01.getConstantValue()) {
                  CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(right_domain_name[i].isGreaterThan(input_domain_name_wildcard[i]).getWire());
                } else {

                }
              } else {
                ConditionalScopeTracker.pushMain();
                ConditionalScopeTracker.push(bit_a0a0a0a2a2a23a01);
                CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(right_domain_name[i].isGreaterThan(input_domain_name_wildcard[i]).getWire());

                ConditionalScopeTracker.pop();

                ConditionalScopeTracker.push(new Bit(true));

                ConditionalScopeTracker.pop();
                ConditionalScopeTracker.popMain();
              }

            }

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_c0gb0k);
          right_domain_name[i].forceEqual(input_domain_name_wildcard[i]);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          {
            Bit bit_a0a2a23a01_0 = UnsignedInteger.instantiateFrom(8, i).isEqualTo(right_index).copy();
            boolean c_a0a2a23a01_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a2a23a01_0);
            if (c_a0a2a23a01_0) {
              if (bit_a0a2a23a01_0.getConstantValue()) {
                CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(right_domain_name[i].isGreaterThan(input_domain_name_wildcard[i]).getWire());
              } else {

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a2a23a01_0);
              CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion(right_domain_name[i].isGreaterThan(input_domain_name_wildcard[i]).getWire());

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }
          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

    return UnsignedInteger.instantiateFrom(1, 1);
  }

  // convert uint_8[] to F_p[8] -- the same as python script
  public static FieldElement[] convert_8_to_Fp_python(UnsignedInteger[] byte_array) {

    FieldElement[] Fp_array = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{8}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    UnsignedInteger large_int = UnsignedInteger.instantiateFrom(2040, 0).copy(2040);
    UnsignedInteger tempt = new UnsignedInteger(2040, new BigInteger("0"));

    // concate uint_8[] to get uint_2040 
    for (int i = 0; i < 255; i++) {
      tempt.assign(UnsignedInteger.instantiateFrom(2040, UnsignedInteger.instantiateFrom(2040, byte_array[i]).shiftLeft((8 * i))), 2040);
      large_int.assign(large_int.add(tempt), 2040);

    }
    //  decompse uint_2040 into bit array 
    Bit[] bit_array = (Bit[]) Bit.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2040});
    bit_array = large_int.getBitElements();


    UnsignedInteger Fp_buffer = UnsignedInteger.instantiateFrom(254, 0).copy(254);
    UnsignedInteger bit_tempt = new UnsignedInteger(254, new BigInteger("0"));
    UnsignedInteger Fp_tempt = new UnsignedInteger(254, new BigInteger("0"));

    // recombine bit array into F_p array 
    // 254 bit will convert to one F_p element 
    // Note that it's not secure to convert 254bit directly since F_p is also 254 bit 
    // Implementation needs to be tuned (revise it to 253bit or increase F_p) 
    // It's enough to support 253bytes input since it's the largest size for input domain name 
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 253; j++) {
        // get the bit 
        bit_tempt.assign(UnsignedInteger.instantiateFrom(254, bit_array[i * 253 + j]), 254);
        // left shift this bit 
        Fp_tempt.assign(bit_tempt, 254);
        for (int k = 0; k < j; k++) {
          Fp_tempt.assign(Fp_tempt.mul(UnsignedInteger.instantiateFrom(2, 2)), 254);
        }
        Fp_buffer.assign(Fp_tempt.add(Fp_buffer), 254);
      }
      // turn uint254 to Fp 
      Fp_array[i].assign(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), Fp_buffer));
      Fp_buffer.assign(new UnsignedInteger(254, new BigInteger("0")), 254);
    }


    return Fp_array;
  }



}
