package xjsnark.e2eFirewall;

/*Generated by MPS */

import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.Bit;
import backend.structure.CircuitGenerator;
import backend.auxTypes.ConditionalScopeTracker;
import backend.auxTypes.SmartMemory;

public class HTTPFirewall {

  // /* The entry function for this class is at the bottom */

  // The string 'HTTP/1.1' in ASCII
  public static final int[] http11_ints = {0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31};

  // Carriage Return (CR) and Line Feed (LF) chars in ASCII
  public static final int cr_int = 0x0d;
  public static final int lf_int = 0x0a;

  // We assume the HTTP message is of at most 500 bytes
  public static final int HTTP_REQUEST_MAX_LENGTH = 500;


  // This function searches through the entire http message
  // and returns the first index with character CR that is followed by character LF
  // That is, http_msg[i] || http_msg[i+1] = CR || LF 
  private static UnsignedInteger get_first_crlf_index(UnsignedInteger[] http_msg) {

    UnsignedInteger cr = UnsignedInteger.instantiateFrom(16, cr_int).copy(16);
    UnsignedInteger lf = UnsignedInteger.instantiateFrom(16, lf_int).copy(16);

    // Create one 16-bit integer by concatenating cr and lf 
    UnsignedInteger CRLF_CONCAT = (UnsignedInteger.instantiateFrom(16, cr).shiftLeft(8)).orBitwise((UnsignedInteger.instantiateFrom(16, lf))).copy(16);


    // A bit to indicate if CRLF has been found 
    UnsignedInteger not_found = UnsignedInteger.instantiateFrom(1, 1).copy(1);

    UnsignedInteger first_crlf_index = UnsignedInteger.instantiateFrom(8, 0).copy(8);

    // We must search through the entire message  
    for (int i = 1; i < HTTP_REQUEST_MAX_LENGTH; i++) {

      // Record the current and previous characters 
      UnsignedInteger curr_char = UnsignedInteger.instantiateFrom(16, http_msg[i]).copy(16);
      UnsignedInteger prev_char = http_msg[i - 1].copy(8);

      // Concatenate prev_char || curr_char into one 16 bit integer  
      UnsignedInteger curr_concat = ((UnsignedInteger.instantiateFrom(16, prev_char).shiftLeft(8)).orBitwise(UnsignedInteger.instantiateFrom(16, curr_char))).copy(16);

      // Compare CRLF_CONCAT with the current concatenation 
      {
        Bit bit_j0o0r = CRLF_CONCAT.isEqualTo(curr_concat).copy();
        boolean c_j0o0r = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_j0o0r);
        if (c_j0o0r) {
          if (bit_j0o0r.getConstantValue()) {

            // We must set first_crlf_index to be i-1 only the first time we enter this loop. 
            // We could use nested loops, 
            // but we do this funny assignment method because of issues with xJsnark's optimizer with some nested loops. 
            // Note that this if_clause is entered multiple times and only the first entry must be recorded. 
            first_crlf_index.assign(UnsignedInteger.instantiateFrom(8, i - 1).mul(not_found).add(first_crlf_index), 8);

            not_found.assign(UnsignedInteger.instantiateFrom(1, 0), 1);
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_j0o0r);

          // We must set first_crlf_index to be i-1 only the first time we enter this loop. 
          // We could use nested loops, 
          // but we do this funny assignment method because of issues with xJsnark's optimizer with some nested loops. 
          // Note that this if_clause is entered multiple times and only the first entry must be recorded. 
          first_crlf_index.assign(UnsignedInteger.instantiateFrom(8, i - 1).mul(not_found).add(first_crlf_index), 8);

          not_found.assign(UnsignedInteger.instantiateFrom(1, 0), 1);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

    return first_crlf_index;
  }

  // This function verifies that the 8 chars preceding the first_crlf_index in http_msg_ram are 'HTTP/1.1'
  private static void match_http(SmartMemory<UnsignedInteger> http_msg_ram, UnsignedInteger first_crlf_index) {
    UnsignedInteger[] http11 = UnsignedInteger.instantiateFrom(8, http11_ints);

    // Perform the verification using the input RAM 
    // We require a RAM as we access indices based on the first_crlf_index, which is variable 
    // and not known at the creation of the circuit. 
    for (int i = 0; i < 8; i++) {
      // If verifyEq fails, the proof generation fails 
      http_msg_ram.read(first_crlf_index.subtract(UnsignedInteger.instantiateFrom(8, i + 1))).forceEqual(http11[7 - i]);
    }
  }


  // The function does the following;
  // (1) Find the first index where the CRLF characters appear (numbers 13, 10 in decimal)
  // (2) Verify the 8 chars preceding the first CRLF is 'HTTP/1.1'
  public static UnsignedInteger test_firewall(UnsignedInteger[] http_msg) {

    // Get the first index where CRLF appears 
    UnsignedInteger first_crlf_index = get_first_crlf_index(http_msg).copy(8);

    // Create a RAM from the http message. 
    // RAM is required as the first CRLF location is variable 
    SmartMemory<UnsignedInteger> http_msg_ram = new SmartMemory(UnsignedInteger.instantiateFrom(8, http_msg), UnsignedInteger.__getClassRef(), new Object[]{"8"});

    // Verifies the http string before the CRLF 
    match_http(http_msg_ram, first_crlf_index.copy(8));

    return first_crlf_index;
  }


}
