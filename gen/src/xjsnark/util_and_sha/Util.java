package xjsnark.util_and_sha;

/*Generated by MPS */

import backend.auxTypes.UnsignedInteger;
import backend.structure.CircuitGenerator;
import backend.auxTypes.SmartMemory;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;

public class Util {

  // Contains various utility functions 
  // Mostly dealing with arrays of uint_8 arrays
  // There are many "Conversion" functions between arrays of different integer lengths (uint_8, _32, _16, ..., _256)

  // ************** Concatenation Functions ****************


  public static UnsignedInteger[] concat(UnsignedInteger[][] inputs) {
    UnsignedInteger[] output = inputs[0];
    for (int i = 1; i < inputs.length; i++) {
      output = concat(output, inputs[i]);
    }
    return output;
  }

  public static UnsignedInteger[] concat(UnsignedInteger[] a1, UnsignedInteger[] a2) {
    int l1 = a1.length;
    int l2 = a2.length;
    UnsignedInteger[] res = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{l1 + l2}, 8);

    for (int i = 0; i < l1; i++) {
      res[i].assign(a1[i], 8);
    }

    for (int i = 0; i < l2; i++) {
      res[i + l1].assign(a2[i], 8);
    }
    return res;

  }


  // ************** Conversion Functions ****************

  public static UnsignedInteger[] convert_8_to_256_array(UnsignedInteger[] input) {
    if (input.length % 32 != 0) {
      throw new IllegalArgumentException("This method only accepts multiple of 32 in bytes.");
    }

    int len_in_256 = input.length / 32;
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len_in_256}, 256);

    for (int i = 0; i < len_in_256; i++) {
      output[i].assign(UnsignedInteger.instantiateFrom(256, 0), 256);
      for (int j = 0; j < 32; j++) {
        output[i].assign(output[i].xorBitwise((UnsignedInteger.instantiateFrom(256, input[i * 32 + j]).shiftLeft(((31 - j) * 8)))), 256);
      }
    }
    return output;
  }


  public static UnsignedInteger[] convert_8_to_32(UnsignedInteger[] input) {
    if (input.length % 4 != 0) {
      throw new IllegalArgumentException("This method only accepts multiple of 4 in bytes.");
    }

    int len_in_32 = input.length / 4;
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len_in_32}, 32);

    for (int i = 0; i < len_in_32; i++) {
      output[i].assign(combine_four_bytes_to_one_32(UnsignedInteger.instantiateFrom(32, input[4 * i]).copy(32), UnsignedInteger.instantiateFrom(32, input[4 * i + 1]).copy(32), UnsignedInteger.instantiateFrom(32, input[4 * i + 2]).copy(32), UnsignedInteger.instantiateFrom(32, input[4 * i + 3]).copy(32)), 32);
    }

    return output;
  }

  public static UnsignedInteger[] convert_32_to_8(UnsignedInteger[] input) {
    int len = input.length;
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len * 4}, 8);

    for (int i = 0; i < len; i++) {
      output[4 * i].assign(UnsignedInteger.instantiateFrom(8, input[i].shiftRight(24)), 8);
      output[4 * i + 1].assign(UnsignedInteger.instantiateFrom(8, input[i].shiftRight(16)), 8);
      output[4 * i + 2].assign(UnsignedInteger.instantiateFrom(8, input[i].shiftRight(8)), 8);
      output[4 * i + 3].assign(UnsignedInteger.instantiateFrom(8, input[i]), 8);
    }

    return output;
  }

  //  output = a1 || a2 || a3 || a4
  public static UnsignedInteger combine_four_bytes_to_one_32(UnsignedInteger a1, UnsignedInteger a2, UnsignedInteger a3, UnsignedInteger a4) {
    return (a1.shiftLeft(24)).orBitwise((a2.shiftLeft(16))).orBitwise((a3.shiftLeft(8))).orBitwise(a4);
  }

  public static UnsignedInteger combine_8_into_64(UnsignedInteger[] input) {
    if (input.length != 8) {
      throw new IllegalArgumentException("This method only accepts 8 uint_8 values.");
    }

    UnsignedInteger output = UnsignedInteger.instantiateFrom(64, 0).copy(64);

    for (int i = 0; i < 8; i++) {
      output.assign(output.orBitwise((UnsignedInteger.instantiateFrom(64, input[i]).shiftLeft(((7 - i) * 8)))), 64);
    }

    return output;
  }

  public static UnsignedInteger combine_8_into_256(UnsignedInteger[] input) {
    if (input.length != 32) {
      throw new IllegalArgumentException("This method only accepts 32 uint_8 values.");
    }

    UnsignedInteger output = UnsignedInteger.instantiateFrom(256, 0).copy(256);

    for (int i = 0; i < 32; i++) {
      output.assign(output.orBitwise((UnsignedInteger.instantiateFrom(256, input[i]).shiftLeft(((31 - i) * 8)))), 256);
    }

    return output;
  }

  public static UnsignedInteger[] convert_256_to_8(UnsignedInteger input) {
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{32}, 8);
    for (int i = 0; i < 32; i++) {
      output[i].assign(UnsignedInteger.instantiateFrom(8, input.shiftRight(((31 - i) * 8))), 8);
    }
    return output;
  }


  public static UnsignedInteger[] convert_16_to_8(long input) {
    UnsignedInteger[] res = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 8);

    res[1].assign(UnsignedInteger.instantiateFrom(8, input), 8);
    res[0].assign(UnsignedInteger.instantiateFrom(8, input >> 8), 8);
    return res;
  }


  public static UnsignedInteger[] convert_4_to_8(UnsignedInteger[] input) {
    int len_in_8 = input.length / 2;

    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len_in_8}, 8);

    for (int i = 0; i < len_in_8; i++) {
      output[i].assign(((UnsignedInteger.instantiateFrom(8, input[2 * i]).shiftLeft(4)).xorBitwise((UnsignedInteger.instantiateFrom(8, input[2 * i + 1])))), 8);
    }

    return output;
  }

  public static UnsignedInteger[] convert_64_to_8(UnsignedInteger input) {
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{8}, 8);

    for (int i = 0; i < 8; i++) {
      output[i].assign(UnsignedInteger.instantiateFrom(8, input.shiftRight(((7 - i) * 8))), 8);
    }

    return output;
  }


  public static UnsignedInteger[] string_to_bytes(String str) {
    int len = str.length();
    UnsignedInteger[] str_bytes = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len}, 8);
    for (int i = 0; i < len; i++) {
      str_bytes[i].assign(UnsignedInteger.instantiateFrom(8, str.charAt(i)), 8);
    }
    return str_bytes;
  }


  public static UnsignedInteger[] convert_hex_string_to_bytes(String hex_string) {
    int len = hex_string.length();

    UnsignedInteger[] output_in_4 = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len}, 4);

    for (int i = 0; i < len; i++) {
      char ch = hex_string.charAt(i);
      if (ch >= 48 && ch <= 57) {
        output_in_4[i].assign(UnsignedInteger.instantiateFrom(4, ch - 48), 4);
      } else if (ch >= 65 && ch <= 70) {
        output_in_4[i].assign(UnsignedInteger.instantiateFrom(4, ch - 65 + 10), 4);
      } else if (ch >= 97 && ch <= 102) {
        output_in_4[i].assign(UnsignedInteger.instantiateFrom(4, ch - 97 + 10), 4);
      }
    }

    UnsignedInteger[] output_in_8 = convert_4_to_8(output_in_4);
    return output_in_8;
  }

  public static UnsignedInteger[] new_zero_array(int len) {
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len}, 8);
    for (int i = 0; i < len; i++) {
      output[i].assign(UnsignedInteger.instantiateFrom(8, 0), 8);
    }
    return output;
  }


  // ************** XOR Functions ****************


  public static UnsignedInteger[] xor_arrays_prefix(UnsignedInteger[] a1, UnsignedInteger[] a2, int len) {
    if (a1.length < len || a2.length < len) {
      throw new IllegalArgumentException("Arrays to XOR aren't long enough");
    }

    UnsignedInteger[] res = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len}, 8);
    for (int i = 0; i < len; i++) {
      res[i].assign(a1[i].xorBitwise(a2[i]), 8);
    }
    return res;
  }


  public static UnsignedInteger[] xor_arrays(UnsignedInteger[] a1, UnsignedInteger[] a2) {
    if (a1.length != a2.length) {
      throw new IllegalArgumentException("Incompatible length");
    }

    int len = a1.length;
    UnsignedInteger[] res = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len}, 8);
    for (int i = 0; i < len; i++) {
      res[i].assign(a1[i].xorBitwise(a2[i]), 8);
    }
    return res;

  }

  // XORs every byte of the input array with the specified byte
  public static UnsignedInteger[] xor_with_byte(UnsignedInteger[] input, UnsignedInteger b) {
    int len = input.length;

    UnsignedInteger[] res = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{len}, 8);
    for (int i = 0; i < len; i++) {
      res[i].assign(input[i].xorBitwise(b), 8);
    }
    return res;
  }

  // ************** Array Manipulation ****************


  public UnsignedInteger[][] append_2d_array(UnsignedInteger[][] base, UnsignedInteger[] item) {
    int len = base.length;
    UnsignedInteger[][] output = new UnsignedInteger[len + 1][];

    for (int i = 0; i < len; i++) {
      output[i] = base[i];
    }
    output[len] = item;
    return output;
  }



  // Reverses an input byte array of specified length
  public static UnsignedInteger[] reverse(UnsignedInteger[] input, UnsignedInteger rev_length) {

    SmartMemory<UnsignedInteger> input_ram = new SmartMemory(input, UnsignedInteger.__getClassRef(), new Object[]{"8"});

    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{input.length}, 8);

    for (int i = 0; i < input.length; i++) {
      {
        Bit bit_a0f0pc = UnsignedInteger.instantiateFrom(8, i).isLessThan(rev_length).copy();
        boolean c_a0f0pc = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0f0pc);
        if (c_a0f0pc) {
          if (bit_a0f0pc.getConstantValue()) {
            output[i].assign(input_ram.read(UnsignedInteger.instantiateFrom(8, rev_length.subtract(UnsignedInteger.instantiateFrom(8, i)).subtract(UnsignedInteger.instantiateFrom(8, 1)))), 8);
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0f0pc);
          output[i].assign(input_ram.read(UnsignedInteger.instantiateFrom(8, rev_length.subtract(UnsignedInteger.instantiateFrom(8, i)).subtract(UnsignedInteger.instantiateFrom(8, 1)))), 8);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

    return output;
  }
  public static UnsignedInteger[] get_prefix(UnsignedInteger[] input, int prefix_length) {
    UnsignedInteger[] output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{prefix_length}, 8);

    for (int i = 0; i < prefix_length; i++) {
      output[i].assign(input[i], 8);
    }
    return output;
  }

  public static UnsignedInteger[][] get_prefix_tail(UnsignedInteger[] input, int prefix_length) {
    UnsignedInteger[] prefix = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{prefix_length}, 8);

    int full_length = input.length;

    UnsignedInteger[] tail = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{full_length - prefix_length}, 8);

    for (int i = 0; i < prefix_length; i++) {
      prefix[i].assign(input[i], 8);
    }

    for (int i = prefix_length; i < full_length; i++) {
      tail[i - prefix_length].assign(input[i], 8);
    }

    return new UnsignedInteger[][]{prefix, tail};
  }

  public static UnsignedInteger[] get_tail(UnsignedInteger[] input, int prefix_length) {
    int full_length = input.length;
    UnsignedInteger[] tail = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{full_length - prefix_length}, 8);

    for (int i = prefix_length; i < full_length; i++) {
      tail[i - prefix_length].assign(input[i], 8);
    }

    return tail;
  }

}
