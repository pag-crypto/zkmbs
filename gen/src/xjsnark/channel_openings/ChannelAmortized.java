package xjsnark.channel_openings;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import backend.auxTypes.UnsignedInteger;
import util.Util;
import xjsnark.poseidon.PoseidonHash;
import xjsnark.aes_gcm.AES_GCM;
import backend.eval.CircuitEvaluator;

public class ChannelAmortized extends CircuitGenerator {



  public static void main(String[] args) {
    Config.arithOptimizerNumThreads = 8;
    Config.arithOptimizerIncrementalMode = false;
    Config.multivariateExpressionMinimization = false;

    Config.writeCircuits = true;
    Config.outputFilesPath = ".";

    new ChannelAmortized();
  }

  public ChannelAmortized() {
    super("ChannelAmortized");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        try {

          // Example commitment string 
          String comm_str = "2db24a9a876fc5395a0a087137c4d73de25a4f2002f384513d8427959247c4cd";

          // Key, iv that were committed to 
          String key_str = "e1a1786a0c146f4b172192141df6ffd9";
          String iv_str = "cf73d63f3ac141740b84c7fd";

          // query is amazon.com 
          String dns_ct_str = "50e2daf49a12e78a4eed77fa7bb76e462287446b510f61f50c3f1c";

          // Convert the strings to circuit input types 

          comm.mapValue(new BigInteger(comm_str, 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

          for (int i = 0; i < key_str.length() / 2; i = i + 1) {
            key[i].mapValue(new BigInteger(key_str.substring(2 * i, 2 * i + 2), 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }

          for (int i = 0; i < iv_str.length() / 2; i = i + 1) {
            iv[i].mapValue(new BigInteger(iv_str.substring(2 * i, 2 * i + 2), 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }

          SN.mapValue(BigInteger.ZERO, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

          for (int i = 0; i < dns_ct_str.length() / 2; i = i + 1) {
            appl_ct[i].mapValue(new BigInteger(dns_ct_str.substring(2 * i, 2 * i + 2), 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }
          for (int i = dns_ct_str.length() / 2; i < 255; i = i + 1) {
            appl_ct[i].mapValue(new BigInteger("0", 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }

        } catch (Exception ex) {
          System.out.println("Error: Issue with entering inputs.");
        }



      }
      public void post() {
        System.out.println("Circuit Output: ");

        System.out.print(output_Fp.getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).toString(16));

      }

    });

  }



  public void __init() {
    comm = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
    SN = new UnsignedInteger(64, new BigInteger("0"));
    appl_ct = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{255}, 8);
    key = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    iv = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{12}, 8);
    output = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{32}, 8);
    output_Fp = new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0"));
  }

  public FieldElement comm;
  public UnsignedInteger SN;
  public UnsignedInteger[] appl_ct;
  public UnsignedInteger[] key;
  public UnsignedInteger[] iv;
  public UnsignedInteger[] output;
  public FieldElement output_Fp;

  @Override
  public void __defineInputs() {
    super.__defineInputs();
    SN = UnsignedInteger.createInput(this, 64);
    comm = FieldElement.createInput(this, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));



    appl_ct = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(appl_ct), 8);












  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();









  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();




    key = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(key), 8);
    iv = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(iv), 8);















  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();

















  }
  public void outsource() {

    // Compute the commitment, which is the Poseidon hash of key || iv 
    UnsignedInteger[] concat = xjsnark.util_and_sha.Util.concat(key, iv);
    UnsignedInteger concat_256 = xjsnark.util_and_sha.Util.convert_8_to_256_array(xjsnark.util_and_sha.Util.concat((UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{4}, 8), concat))[0].copy(256);
    FieldElement comm_cal = PoseidonHash.poseidon_hash(new FieldElement[]{new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("0")), FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), concat_256).copy()}).copy();

    // Verify that the two commitments are equal 
    comm.forceEqual(comm_cal);

    // Compute iv xor (0^32 || SN)  
    // this acts as the iv for this TLS record 
    UnsignedInteger[] iv_record = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{12}, 8);

    UnsignedInteger SN_96 = UnsignedInteger.instantiateFrom(96, SN).copy(96);

    for (int i = 0; i < 12; i++) {
      iv_record[i].assign(iv[i].xorBitwise(UnsignedInteger.instantiateFrom(8, SN_96.shiftRight((8 * (11 - i))))), 8);
    }

    // Use the input keys to decrypt at the specified block 
    output = AES_GCM.aes_gcm_decrypt(key, iv_record, appl_ct);

    // For logging output 
    output_Fp.assign(comm_cal);

  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
