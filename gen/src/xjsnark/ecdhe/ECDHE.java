package xjsnark.ecdhe;

/*Generated by MPS */

import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.FieldElement;
import xjsnark.util_and_sha.Util;
import java.math.BigInteger;
import backend.structure.CircuitGenerator;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;

public class ECDHE {

  // The following file performs functions required for ECDHE on curve secp256.
  // Some functions from the ecKeyKnowledge example from xJsnark are used as is below.

  // Given the two public points exchanged by the parties of the DHE
  // and one party's secret share (the client's in our case) 
  // this function returns the final secret derived.
  public static UnsignedInteger[] DHExchange(FieldElement Ax, FieldElement Ay, FieldElement Bx, FieldElement By, UnsignedInteger sk_a) {

    FieldElement[] A_calculated = ECDHE.multiplyGenerator(sk_a.copy(256));

    A_calculated[0].forceEqual(Ax);
    A_calculated[1].forceEqual(Ay);

    FieldElement[] secret_point = multiplyPoint(Bx.copy(), By.copy(), sk_a.copy(256));
    UnsignedInteger secret_bits = UnsignedInteger.instantiateFrom(256, secret_point[0]).copy(256);
    UnsignedInteger[] DHE_secret = Util.convert_256_to_8(secret_bits.copy(256));

    return DHE_secret;
  }

  // Multiplies the hardcoded generator of curve secp256 
  // by the input scalar
  public static FieldElement[] multiplyGenerator(UnsignedInteger sk) {
    FieldElement Gx = FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), "48439561293906451759052585252797914202762949526041747995844080717082404635286").copy();
    FieldElement Gy = FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), "36134250956749795798585127919587881956611106672985015071877198253568414405109").copy();

    FieldElement[] A = multiplyPoint(Gx.copy(), Gy.copy(), sk.copy(256));
    return A;
  }


  // THE FOLLOWING FUNCTIONS ARE FROM THE ecKeyKnowledge EXAMPLE FILE from xJsnark
  // with only slight modifications.

  public static FieldElement[] multiplyPoint(FieldElement base_x, FieldElement base_y, UnsignedInteger sk) {

    // Additional safety checks (just precautionary) 

    FieldElement[][] table = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{256, 2}, new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"));
    table[0][0].assign(base_x);
    table[0][1].assign(base_y);


    for (int i = 1; i < 256; i++) {
      table[i] = doublePoint(table[i - 1][0].copy(), table[i - 1][1].copy());
    }

    // a boolean to keep track when it's safe to apply the addition formula of affine points 
    Bit init = Bit.instantiateFrom(false).copy();

    FieldElement p_x = new FieldElement(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), new BigInteger("0"));
    FieldElement p_y = new FieldElement(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), new BigInteger("0"));

    for (int i = 0; i < 256; i++) {
      {
        Bit bit_a0q0r = sk.getBitElements()[i].copy();
        boolean c_a0q0r = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0q0r);
        if (c_a0q0r) {
          if (bit_a0q0r.getConstantValue()) {
            {
              Bit bit_a0a0a2a0a61a71 = init.copy();
              boolean c_a0a0a2a0a61a71 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a2a0a61a71);
              if (c_a0a0a2a0a61a71) {
                if (bit_a0a0a2a0a61a71.getConstantValue()) {
                  FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
                  p_x.assign(r[0]);
                  p_y.assign(r[1]);
                } else {
                  init.assign(Bit.instantiateFrom(true));
                  p_x.assign(table[i][0]);
                  p_y.assign(table[i][1]);

                }
              } else {
                ConditionalScopeTracker.pushMain();
                ConditionalScopeTracker.push(bit_a0a0a2a0a61a71);
                FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
                p_x.assign(r[0]);
                p_y.assign(r[1]);

                ConditionalScopeTracker.pop();

                ConditionalScopeTracker.push(new Bit(true));

                init.assign(Bit.instantiateFrom(true));
                p_x.assign(table[i][0]);
                p_y.assign(table[i][1]);
                ConditionalScopeTracker.pop();
                ConditionalScopeTracker.popMain();
              }

            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0q0r);
          {
            Bit bit_a0a0q0r = init.copy();
            boolean c_a0a0q0r = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0q0r);
            if (c_a0a0q0r) {
              if (bit_a0a0q0r.getConstantValue()) {
                FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
                p_x.assign(r[0]);
                p_y.assign(r[1]);
              } else {
                init.assign(Bit.instantiateFrom(true));
                p_x.assign(table[i][0]);
                p_y.assign(table[i][1]);

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a0q0r);
              FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
              p_x.assign(r[0]);
              p_y.assign(r[1]);

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              init.assign(Bit.instantiateFrom(true));
              p_x.assign(table[i][0]);
              p_y.assign(table[i][1]);
              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

    return new FieldElement[]{p_x.copy(), p_y.copy()};
  }

  public static FieldElement[] addPoints(FieldElement x1, FieldElement y1, FieldElement x2, FieldElement y2) {
    FieldElement lambda = (y2.subtract(y1)).div((x2.subtract(x1))).copy();
    FieldElement xr = lambda.mul(lambda).subtract(x1).subtract(x2).copy();
    FieldElement yr = lambda.mul((x1.subtract(xr))).subtract(y1).copy();
    return new FieldElement[]{xr.copy(), yr.copy()};
  }

  public static FieldElement[] doublePoint(FieldElement x1, FieldElement y1) {
    FieldElement lambda = (FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), 3).mul(x1).mul(x1).add(FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), -3))).div((FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), 2).mul(y1))).copy();
    FieldElement xr = lambda.mul(lambda).subtract(x1.mul(FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), 2))).copy();
    FieldElement yr = lambda.mul((x1.subtract(xr))).subtract(y1).copy();
    return new FieldElement[]{xr.copy(), yr.copy()};
  }

}
